# Microservices: Introduction

We are creating a microservice: a **shipping container management platform**. 

In traditional monolith applications, all of an organization's features are written into one single application. Sometimes they are grouped by their type, such as controllers, entities, factories, etc. Other times, in larger applicaitons, features are separated by concern or feature (may have an auth package, friends package, articles package, etc), which may concern their own factories, services, repositories, models, etc. Ultimately, however, they are grouped together in the same codebase.

A microservice is the concept of taking that second approach slightly further, and separating their concerns into their own, independent runnable codebase. Microservices are useful because we **reduce complexity**. Splitting features into microservices allows you to code in smaller chunks. Monoliths risk having some domains to become tightly coupled to each other and hard to separate. This could potentially lead to more bugs and such. Scalability refers to a system's ability to handle a growing amount of work and its potential to be enlarged to handle a growing amount of work. Microservices also allow us to **scale codebases separately**, whereas in a monolith you would have to scale the entire codebase. For instance, in a monolith, if one codebases is repeatedly experiencing issues, you would have to scale the entire codebase to attempt to fix the bug. With a microservice, you can simply probe into the specific codebase that is experiencing issues. **Therefore, microservices allow for you to have separation of individual services and more efficient horizontal scaling.**


Go is suited very well to work with microservices. It is lightweight, very fast and has great support for concurrency.

# Introducing protobuf/gRPC

Microservices are split into separate codebases, so we will have to deal with communication issues that could arise. In a monolith setting, communicaiton is not an issue because all the code you call is somewhere else in the codebase. Microservices do not have this ability, as they live in separate places. There needs to be a way for these independent services to talk to one another with little delay. Possible solutions to this would be to use traditional REST, like JSON or XML over http. However, we face to issue of service A having to encode its dta into JSON/XML, send a large string over the wire, to service B, which then has to decode this message from JSON, back into the code. We may face issues with scaling with this. Whilst you're forced to adopt this form of communication for web browsers, services can just communicate with each other in any format they wish. 

**gRPC** is a lightweight binary based remote procedure call (RPC; one program can use to request a service from a program located  in another computer on a network without having to understand the network's details) communication protocol by Google. gRPC uses binary as its core data format. With JSON, we would see a string of http being sent over, which can contain bulky metadata about its encoding format (about its length, content format and various other information). This is so the server can inform a traditionally browser based client what to expect. We do not require this while when we are communicating between two services. Binary will suffice and is more lightweight. gRPC uses HTTP 2.0 spec, which allows for the use of binary data. It allows for bi-directional streaming. HTTP 2 makes applications more faster, simpler and robust. Its primary goal is to reduce the delay by enabling full request and response multiplexing, minimize protocol overhead through efficient compression of HTTP header fields, and add support for rquest prioritization and server push. 

gRPC has an interchange digital subscriber line (DSL) called **protobuf**, which allows you to define an interface to your service using a developer friendly format. 

In `consignment.proto`, we define your service, which should contain the methods that you wish to expose to other services. Then you define your message types, these are effectively your data structure. Protobuf is statically typed, and you can define custom types. Messages are themselves just custom types. There are two libraries at work here, messages are handled by protobuf, and the service we defined is handled by a gRPC protobuf plugin, which compiles code to interact with these types, i.e., the `service` part of our proto file. 
